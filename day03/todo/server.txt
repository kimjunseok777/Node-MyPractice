

) express.txt 공부 모두 바치면 server.txt 로 넘어오자


) ORM
        Object Relational Mapping
        객체랑 관계형 데이터베이스랑 연결시켜주는 것이다 (sql 대신에 자바스크립트 객체를 쓰면, sql 로 자동으로 변환해주는 것이다)
        -->  sql 을 몰라도 개발할 수 있게 도와주는 친구이다 (자바스크립트로 백엔드 코드를 작성할 수 있다)
        객체와 관계형 DB를 맵핑
        SQL 없이도 간단한 쿼리를 작성할 수 있다
        생산성 때문에 많이 사용한다

        단점 : 복잡한 SQL 은 작성할 수 없다
                  불필요한 쿼리가 발생할 수 있다 (최적화가 되지 않는다)
            
        종류 :
            - sequelize : express 랑 가장 많이 사용하는 orm (하지만, 요즘은 express 많이 사용 안한다  -->  옛날 거다)
            - typeorm : nest-js 랑 가장 많이 사용하는 orm, javascript 기반 백엔드에서는 가장 흔히 사용되는 orm
            - prisma : front-end (next-js) 에서 권장하고 있는 orm  -->  NextJs 는 풀스택 프레임워크이다
            - drizzle-orm : 요즘 가장 주목받고 있는 orm

            ==>  우리가 사용해볼 ORM 의 종류는 sequelize 사용할 것이다

        npm i sequelize sequelize-cli
        npx sequelize init


) Cookie
        client 에 웹 브라우저에 저장되는 key , value 로 이루어진 작은 데이터 파일
        -->  개발자 도구에서 Application 들어가보면 Storage , Cookies 있는 것 확인할 수 있다
        http-only 라는 옵션을 통해서 외부에서의 접근을 차단할 수 있고
        client 에서 따로 설정하지 않아도 자동으로 server 와 주고 받기가 가능하다

        express 에서 cookie 를 사용하려면 cookie-parser 를 설치해야한다
        npm i cookie-parser


) JWT
        Json Web Token  -->  토큰은 작은 값, 조그마한 무언가 ... 등등 이라는 뜻이다
        json 을 암호키로 암호화하여 소프트웨어 간 주고 받을 수 있는 문자열로 이루어진 값
        ex)
        const token = jwt.sign({
            userId : ?
            userToken : ?
            ... 즉, 객체를 넣으면 된다

            aud: "kjs",
            expiredIn: "30m"
        },  암호화키,  옵션)

        npm i jsonwebtoken


) BCRYPT
        단방향 암호화 라이브러리
        -->  단반향이기에 복구화가 불가능 하다  -->  알고리즘이나 키로 한번 묶어주면 복구화가 안된다  -->  즉, 원래의 값을 찾을 수 없다
        회원가입시 사용자가 입력한 비밀번호를 암호화하여 바교만 가능하도록한 라이브러리 (개발자들도 비밀번호를 알 수 없다)

        npm i bcrypt


==>  이렇게 하면 로그인을 만들 수 있는 최소한의 조건을 갖춘 것이다 (ORM , Cookie , JWT , BCRYPT)


===================================================================================================


** 경로 이동 : todo

        -->  npm init

        -->  npm i express

        -->  npm i sequelize sequelize-cli  -->  npx sequelize init

        -->  npm i cookie-parser

        -->  npm i jsonwebtoken

        -->  npm i bcrypt

        -->  npm i nodemon

        -->  package.json 에 "type": "module" 도 정의해주자  -->  script 에 dev 도 작성해주자


===================================================================================================


** 경로 이동 : todo  -->  app.js

        -->  express , cookieParser 두개 import 받아서 사용해주자

        -->  이제 데이터 베이스 연결해줘야한다

        -->  npx sequelize init  -->  config , migrations , models , seeders 폴더 생간다

        ) config : 데이터 베이스 설정하는 것이다  -->  비밀번호 입력하면 된다

        ) migrations : 데이터를 옮기는 것 (데이터에 변동이 발생했을 때 사용하는 폴더)

        ) models : 테이블을 객체로 자동 생성 시켜줄 수 있는것 (sql 쓸 필요 없다)  -->  객체로 모델을 정의할 수 있다

        ) seeders : 기본 디폴트 파일들을 넣는 것 (처음 데이터베이스를 생성하고 연결했을 때 사용하는 폴더)

        ==>  config , models 사용할 것이다


===================================================================================================


** 경로 이동 : config  -->  config.json

        ) config : 데이터베이스를 설정하는 것이다

        -->  password 에 MySQL 설치할 때 정했던 비밀번호로 넣어주자  -->  12345678 (문자열로 넣어줘야한다) 

        -->  database 부분은 이름을 나타낸다  -->  todo 로 바꿔주자

        -->  모두 마쳤으면 이제 데이터베이스가 연결이 될 준비가 된 것이다


** 경로 이동 : models  -->  index.js

        ) models : 테이블을 객체로 자동 생성 시켜줄 수 있는것 (sql 쓸 필요 없다)  -->  객체로 모델을 정의할 수 있다

        -->  데이터베이스 init 되는 코드만 작성해줄 것이다

        -->  싹다 지워주자  -->  config 를 import 받아와서 사용해주자  -->  database , db 만들어주자

        -->  db 설정 모두 마쳤으면, 이제 app.js 에서 import 받아서 사용해주자 (db 연결해준 것이다)


===================================================================================================


** 경로 이동 : app.js

        -->  db.sequelize.sync() 해서 연결시켜주자

        ) sequelize : ORM 의 한 종류이다  -->  객체와 관계형 DB를 맵핑 시켜준다

        -->  npm i mysql2  -->  MySQL 과 연결시켜준 것이다


===================================================================================================


** 경로 이동 : MySQL

        -->  워크벤치 열어줘서 todo 라는 database 만들어주자  -->  create database todo;

        -->  이제 DB 를 정의하면 끝이다


** 경로 이동 : models  -->  user.model.js

        -->  모델을 정의해보자


** 경로 이동 : user.model.js  -->  index.js

        -->  ex) db.Users = Users  -->  앞에서 만든 Users 를 import 받아서 db 에 설치해준 것이다

        -->  워크벤치 들어가보면, 투두 db 에 데이블에 users 생긴 것 확인할 수 있다  -->  sql 쓰지 않고도 데이터베이스와 테이블 만든 것이다

        -->  ORM 은 sql 을 쓰지 않고, 자바스크립트의 객체만으로도 sql 을 쓴것처럼 할 수 있는게 ORM 이다


===================================================================================================


** 경로 이동 : routes  -->  user.js

        -->  post 메소드로 회원가입 요직 만들어주자

        -->  export 해주고, app.js 로 가서 User 라는 이름으로 import 받아서 DB 에 설치해주자


** 경로 이동 : Thunder Client

        -->  body 데이터로 email , password 데이터 보내보고 회원가입 요직 잘 작동하는지 확인해보자
                (똑같은 email 두번 이상 보냈을 때, 이미 존재한다고 뜨면 잘 된 것이다)

        -->  MySQL  -->  select * from todo.users;  -->  비밀번호 암호화되서 값이 들어간 것을 확인할 수 있다

        -->  이렇게 하면 회원가입 db 만드는 것 완료한 것이다


===================================================================================================


==>  프론트엔드 서버  -->  GoDaddy )대표적으로 많이 사용한다  -->  도메인을 구매해서 사용할 수 있다 ex) naver.com 같은 것들 (1년에 25,000원 정도 한다)


===================================================================================================


** 경로 이동 : user.js

        -->  회원가입 로직 만들어줬으니, 이제 로그인 로직 만들어주자

        -->  router.post("/sign-in")  -->  작성해주자

        -->  로그인 로직 모두 만들었으면, 이제 jwt 토큰 만들기 해볼 것이다 (JsonWebToken)

        -->  jwt 를 import 받아서 사용해주자

        -->  jwt.sign 의 두번째 인자로 'secret' 이 들어가는데, 대놓고 'secret' 이라고 적어놓으면 해커들이 갈취하기 쉽다  -->  이 값을 환경에다가 숨겨야한다

        -->  하지만, 우리는 local 개발환경이기에 환경변수까지는 안 할 것이고, 다른 방법으로 해주자  -->  .env 만들어주자


** 경로 이동 : .env

        -->  JWT_SECRET 에 아무 값이나 막 적어주자 (암호화된 값을 적어주면 된다)  -->  해커에게 털리면 큰일난다

        -->  백슬래시 ( \ ) 만 안들어가게 막 적어주자

        -->  이 env 파일을 깃허브에 올리면 안된다  -->  올라가지 않게 gitignore 에 등록해주자

        -->  깃허브에 올라가지 않기에, 협업하는 사람들이 이 값이 뭐인지 알고 있어야한다  -->  .env.example 만들어주자


** 경로 이동 : .env.example

        -->  ex) JWT_SECRET = jwtkey  -->  jwt 의 key 가 들어간다고 알려준 것이다

        -->  협업할 때, 우린 이런 환경변수가 있다고 알려주는 것이다


===================================================================================================

npm i dotenv  -->  나의 컴퓨터에 유효한 변수이다 (쉽게 환경변수를 설정한 것이다  -->  원래는 이렇게 하면 안된다)

===================================================================================================


** 경로 이동 : app.js

        -->  dotenv 를 import 받아서 config 로 실행시켜주자  -->  이제 어디에서든 사용할 수 있는 친구가 된 것이다

        -->  config.json 에 데이터베이스 비밀번호가 대놓고 적혀있으면 안되기에 dotenv 를 사용해주자


** 경로 이동 : config.json

        -->  app.js 에서 dotenv 실행시켜줬는데, 이 config 파일을 서버가 실행되기 전에 실행되어야하는 파일이다

        -->  json 파일을 js 파일로 바꿔주자  -->  dotenv 모듈을 사용하려면, json 이 아닌 js 로 바꿔줘야한다

        -->  js 파일로 바꿔주고, dbConfig 변수에 담아주고 export 시켜주자

        -->  app.js 가 실행되기 전에 등록이 되는 곳이기에 dotenv 를 여기서 또 import 받아서 사용해주자

        -->  userName 이나 password 를 데이터베이스에서 꺼내와야하는데, 아직 등록을 안했으니 등록해주자


** 경로 이동 : .env

        -->  config 에 있는 내용 (username, password, database ... 등등) .env 에 작성해주자

        -->  host, username, password, db 작성해주자

        -->  .env 는 환경변수를 로컬환경에서 쉽게 적용시켜주는 친구이다


** 경로 이동 : config.js

        -->  value 값들에 process.env 적어주고, env 파일에서 작성했던 것 적어주면 된다

        -->  나중에는 env 에 있는 값들이, 실제 데이터베이스 서버의 ip 로 바뀌는 것이다


** 경로 이동 : models  -->  index.js

        -->  config['development']  -->  이거 앞에서 dbConfig 로 모듈화했던 것 import 받아서 바꿔주자

        -->  ex)  dbConfig['development']

        -->  이렇게 하면 dotenv 사용할 준비 모두 마친 것이다

        -->  환경변수는 수정이 됐으면, 서버를 다시 껐다가 켜줘야 적용이 된다


===================================================================================================


** 경로 이동 : routes  -->  user.js

        -->  이제 secret 대신 process.env.JWT_SECRET 적으면 된다  -->  이 다음으로는 옵션이 들어간다

        -->  토큰 생성과 적용시키는 것 모두 마쳤으면, 실제로 로그인을 해보고 암호화된 토큰값이 제대로 오는지 확인해보자


** 경로 이동 : Thunder Client

        -->  post 의 sign-in 으로 회원가입된 email 과 password 를 보내고, 토큰 값이 제대로 오는지 확인해보자

        -->  이제 todoApi 만들어볼 것이다


===================================================================================================


테이블의 관계 ( 1:1 / 1:N / N:M )

) 1 : 1
        유자가 가질 수 있는 관계가 하나밖에 없다는 것
        1명의 사용자는 1개의 프로필을 가질 수 있는 것이 1 대 1 관계이다
        한명의 사용자가 2개의 프로필을 가지려고 하면 이상현상이 발생한다

) 1 : N
        1명의 사용자는 여러 개시글을 작성할 수 있는 것이다  -->  ex) 인스타 피드 한 유저가 여러개 올릴 수 있다
        1개의 포스트가 여러명의 사용자를 가지려고 하면 이상현상이 발생한다  -->  ex) 다른 사람이 한 유저의 인스타 피드 작성하는 것 안된다 (유저 본인만 된다)

) N : M
        팔로잉 팔로워 모두 여러명 가질 수 있다
        한명의 유저가 여러명의 팔로잉을 할 수 있고, 여러명의 팔로워를 가질 수 있다


==>  이것들을 테이블의 관계라고 한다 (이상현상을 방지하기 위해 나온 친구들이다)


===================================================================================================


) 이상현장 정의

) sequelize 에서의 이상현상 정의

        - blongsTo
        - hasOne
        - hasMany
        - belongsToMany


) 1 : 1
        User.hasOne(UserProfile, {foreignKey : "user_id"})  -->  hasOne 을 사용해서 한명의 유저는 하나의 프로필을 갖는다는 것이다
        UserProfile.belongsTo(User, {  -->  반대로 작성해준다  -->  컬럼이 생성된다
                foreignKey : {"user_id"},
                ...option
        })
        -->  belongsTo 이라고 한 것이 userId 라는 컬럼이 생긴다 (belongsTo 는 컬럼이 생기는 곳이다)
        -->  UserProfile 에 userId 라는 컬럼이 생긴 것이다

) 1 : N
        Post.hasMany(User, {foreignKey : "user_id"})  -->  post 에 userId 가 있어야 되니, post 에 hasMany 를 달아준 것이다
        User.belongsTo(Post, {foreignKey : "user_id"})

) N : M
        중간 테이블 생성 (새로운 테이블 생성)  -->  한 유저가 여러개의 userId 를 가질 수는 없기 때문에, 새로운 테이블 생생성해서 관계지어주는 것이다
        following_follower  -->  테이블 생성
        followerId  followingId  -->  둘다 userId 이다 (새로운 중간 테이블을 생성한 것이다)
        1                   2   -->  1번이 2번 팔로우 하고 있다는 것
        2                   1   -->  2번이 1번 팔로우 하고 있다는 것
        2                   3   -->  2번이 3번 팔로우 하고 있다는 것

        User.belongsToMany(User {as: 'following' , through: 'following_follower' , foreignKey: "followingId"})  -->  as 는 별병 달아준 것이다
        User.belongsToMany(User {as: 'follower' , through: 'following_follower' , foreignKey: "followerId"})  -->  foreignKey 는 컬럼명 만들어준 것이다

        ==>  이러면 following_follower 테이블이 아예 새로 생성되는 것이다 (중간 테이블 역할을 한다)

        -->  이제 투두 모델 생성해주자


===================================================================================================


** 경로 이동 : models  -->  todo.model.js

        -->  투두 모델을 만들 것인데, user.model.js 와 똑같은 형태이니 복사해서 가져와주자

        -->  투두 테이블 만들고 hasMany 로 관계 지어줬으면, 이제 user.model 도 관계 지어주자


** 경로 이동 : user.model.js

        -->  투두테이블과 마찬가지로 관계 지어주자


===================================================================================================


** 경로 이동 : index.js

        -->  todo.model.js 에서 만든 테이블도 db 에 설치해주자  -->  ex) db.Todo = Todo

        -->  model 매개변수로 db 실행시켜주는 요직 init 부분 밑에 하나 더 만들어주자

        -->  모두 마쳤으면 워크벤치 들어가서 확인해주자  -->  todos 테이블의 컬럼에 userId 있으면 데이터베이서 생성에 성공한 것이다


===================================================================================================


userId 라는 값을 사용자에게 응답을 받아야한다  -->  어떻게 응답받을지 로그인 전략을 짜야한다

데이터를 전송할 때 인증토큰을 넣어서 같이 전송을 하는데, 우리는 이 accessToken 을 받으면 디코드해야한다  -->  암호화를 풀어야한다
                                                                                                                                                                             -->  암호화 푼 것을 다음으로 넘겨주는 코드를 작성해야한다

) 로그인 전략

        토큰은 어떻게 받을 것인가?  -->  클라이언트 한테 로그인할 때 jwt 토큰 줬었다 (클라이언트도 이 토큰을 간직하고 있다가, 요청을 할 때마다 이 토큰을 실어서 보낼 것이다)
        로그인 후에, 다음 request 때마다 사용자는 이 토큰을 실어서 백엔드에게 요청하는 것이다 (유저가 자신임을 증명하는 수단이다)

        이때 백엔드 개발자가 토큰 전달받는 방법을 정해서 알려줄 것이다  -->  ex) 쿠키, 헤더, 바디 ... 등등에 데이터를 실어서 주세요 (즉, 프론트는 다음 req 에 토큰을 실어서 보낼 의무가 있다)

        가장 많이 쓰이는 방법은 request 에 header 에서 데이터를 가져올 것이다  -->  header 에서 token 을 꺼내서 유효한지, 유효하지 않은지 검사하고 디코드할 것이다
        jwt 토큰을 디코드 (암호화 풀기) 했을 때 userId 가 있다  -->  즉, 누가 글을 썼는지 알 수 있게 되는 것이다 (어떤 유저가 액션을 취했는지 알 수 있다)
       
        ==>  이 미들웨어 코드를 작성해볼 것이다


===================================================================================================


** 경로 이동 : middleware  -->  JwtAuth.js

        -->  jwt 디코드하고 넘겨주는 미들웨어 만들어주자


** 경로 이동 : user.js

        -->  로그인 로직에서 주소의 다음 인자로, 콜백함수 전에 JwtAuth 를 import 받아서 사용해주자 (미들웨어 끼워준 것이다)


===================================================================================================


** 경로 이동 : routes  -->  todo.js

        -->  todo 라우터 추가해주자  -->  이렇게 라우터 추가하면, 반드시 app.js 에 가서 추가해줘야한다

        -->  ex) app.use("/todo", Todo)


** 경로 이동 : Thunder Client

        -->  POST 메소드로 "/todo" 로 send 보내보면 JwtAuth 에서 콘솔 찍은 것들 잘 뜨면 미들웨어 잘 작동하는 것이다 (로그인 후에 해줘야한다)

        -->  JwtAuth 요청이 잘되고, 디코드가 잘되면 userId 가 있다  -->  이 userId 를 req.user 에 담아서 next 로 넘겨주는 것이다

        -->  JwtAuth 의 역할은 요청 중간에서 jwt 토큰의 암호화를 풀고, 그 안에 있는 값을 다시 request 에 담아서 보내주는 역할이다

        -->  즉, JwtAuth 의 역할은 로그인이 안되어있는 유저를 거를 수 있는 것이다 (요청이 아예 도달하지 못하게 하는 역할을 할 수도 있는 것이다)


===================================================================================================